import numpy as np
import matplotlib.pyplot as plt

#---simple Radial Basis Function (RBF) Network----

class RBFNetwork
    def __init__(self, num_inputs, num_centers, num_outputs)
        self.num_inputs = num_inputs
        self.num_centers = num_centers
        self.num_outputs = num_outputs

        # Randomly choose centers
        self.centers = [np.random.uniform(-1, 1, num_inputs) for _ in range(num_centers)]

        # Output layer weights
        self.weights = np.random.rand(num_centers, num_outputs)

    # Gaussian radial basis function
    def _basis_function(self, center, data_point, sigma=1.0)
        return np.exp(-np.linalg.norm(center - data_point)2  (2  sigma2))

    # Calculate activations for each center
    def _calculate_activations(self, X)
        G = np.zeros((len(X), self.num_centers))
        for i, data_point in enumerate(X)
            for j, center in enumerate(self.centers)
                G[i, j] = self._basis_function(center, data_point)
        return G

    # Train the network using pseudo-inverse
    def train(self, X, y)
        G = self._calculate_activations(X)
        X = np.array(X)
        y = np.array(y)
        self.weights = np.dot(np.linalg.pinv(G), y)

    # predict output for new input data
    def predict(self, X)
        G = self._calculate_activations(X)
        X = np.array(X)
        return np.dot(G, self.weights)

#---Example usage---
X = np.linspace(-1, 1, 10).reshape(-1, 1)
Y = np.sin(X)

rbf = RBFNetwork(num_inputs=1, num_centers=5, num_outputs=1)
rbf.train(X, Y)

X_test = np.linspace(-1, 1, 100).reshape(-1, 1)
y_pred = rbf.predict(X_test)

plt.plot(X, Y, 'bo', label='Training data')
plt.plot(X_test, y_pred, 'r-', label=RBF Output)
plt.legend()
plt.show()